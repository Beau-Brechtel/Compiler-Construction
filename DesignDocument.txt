Beau Brechtel

Design Document

Work In Progress Grammar

            program         -> func_decl_list 
            func_decl_list  -> func_decl | func_decl_list func_decl 
            func_decl       -> type IDENTIFIER () { stmt_list } ;
            stmt_list       -> stmt | stmt_list stmt 
            stmt            -> return_stmt | var_decl | assignment | if_stmt| while_stmt | for_stmt
            return_stmt     -> "return" Expression ;
            var_decl        -> type IDENTIFIER = Expression ; | type IDENTIFIER ;
            expr_stmt       -> IDENTIFIER = Expression ;
            if_stmt         -> if ( Expression )  { stmt_list } | if ( Expression ) { stmt_list } else { stmt_list } ;
            while_stmt      -> while ( Expression ) { stmt_list } ;
            for_stmt        -> for (  var_decl | assignment ; Expression ; assignment ) { stmt_list } ;
            type            -> int | float | char | double 
            bool_expr       -> expr > expr | expr < expr| expr == expr | expr != expr | expression
            expression      -> term  etail
            etail           -> + term etail | - term etail | nothing
            term            -> factor ttail
            ttail           -> * factor ttail | / factor ttail | nothing
            factor          -> ( expression ) | NUM | ID 


Errors:
    Will be able to handle different errors in differetn areas of compiler.

    Lexer -> Unknown token sends a lexer error

Main:
    - Has a list of args that user can use when running compiler
    -l runs lexer and outputs tokens
    
# Used Copilot in helping structure file as well as create regular expressions
Lexer

    Keywords: 
        - if
        - else 
        - while
        - for
        - return

    Token Object Keeps Track of:
        - type
        - value
        - line
        - column

    Identifiers Definition: A letter or an underscore followed by any number of optional letters, digits, or underscores

    Before we go through every line and column I get rid of any comments by finding and replacing them with ''.

    First looks for keywords then numbers, then identifiers, then strings, then operators (2 character ones first), and then whitespaces(do this so we can check token type and if whitespace we dont add it to token list).

    Go through line by line and character by character tyring to make a match with one of my token types. If i go through all my token types and dont get a match call it an unknown token.

    Once we reach the end of the lines add an EOF token to tell us we are done (might get rid of later)

Parser 
    - Looked back at COMP 3220 parser for inspiration
    - https://supunsetunga.medium.com/writing-a-parser-getting-started-44ba70bb6cc9 
    - For now a program has to start with a function with nothing before it so no variable declarations or anything
    - Using my ast structure I bascially just follow my grammar adding ast nodes as I match up correct syntax
    - Very strict on type checking, no conversions so if something is an int everything that makes it up needs to be an int
    - As of now when dealing with boolean expressions types arent as strict

AST.py
    - Abstract syntax tree object based off the AST given in the COMP 3220 assignments
    - Basically just a tree that has a node that can point down to a child or right to a sibling

SymbolTable.py
    - Really just a dictionary with symbols that you can lookup by symbol and scope


