Beau Brechtel

Design Document

Grammar

            program         -> decl | decl_list decl
            decl            -> type ID func_decl_tail | type Identifier var_decl_tail
            func_decl_tail  -> (params) { stmt_list } ;
            stmt_list       -> stmt | stmt_list stmt 
            stmt            -> return_stmt | var_decl | if_stmt | while_stmt | for_stmt | expr_stmt ;
            return_stmt     -> "return" Expression ;
            var_decl_tail   -> = bool_expr ; | ;
            expr_stmt       -> ID = bool_expr 
            if_stmt         -> "if" ( Expression )  { stmt_list } | "if" ( Expression ) { stmt_list } "else" { stmt_list } ;
            while_stmt      -> "while" ( Expression ) { stmt_list } ;
            for_stmt        -> "for" (  var_decl | expr_stmt ; bool_expr ; expr_stmt ) { stmt_list } ;
            type            -> INT | FLOAT | CHAR
            bool_expr       -> expression > expression | expression < expression| expression == expression | expression != expression | expression
            expression      -> term  etail
            etail           -> + term etail | - term etail | nothing
            term            -> factor ttail
            ttail           -> * factor ttail | / factor ttail | nothing
            factor          -> ( expression ) | NUM | ID | func_call
            func_call       -> ID (args)


Errors:
    Will be able to handle different errors in differetn areas of compiler.

    Lexer -> Unknown token sends a lexer error

    Parser -> Mismatch of what the next token should be sends error
              Mismatch of type throws parser error 
              Undeclared variables will throw error
              

Main:
    - Has a list of args that user can use when running compiler
    -l runs lexer and outputs tokens
    -p runs parser and outputs AST and symbol table
    -t runs three address code and outputs TAC
    -o1 runs optimization 1 which is just constant folding and gets rid of some unnecessary temp variables 
    
# Used Copilot in helping structure file as well as create regular expressions
Lexer

    Keywords: 
        - if
        - else 
        - while
        - for
        - return

    Token Object Keeps Track of:
        - type
        - value
        - line
        - column

    Identifiers Definition: A letter or an underscore followed by any number of optional letters, digits, or underscores

    Before we go through every line and column I get rid of any comments by finding and replacing them with ''.

    First looks for keywords then numbers, then identifiers, then strings, then operators (2 character ones first), and then whitespaces(do this so we can check token type and if whitespace we dont add it to token list).

    Go through line by line and character by character tyring to make a match with one of my token types. If i go through all my token types and dont get a match call it an unknown token.

    Once we reach the end of the lines add an EOF token to tell us we are done (might get rid of later)

Parser 
    - Looked back at COMP 3220 parser for inspiration
    - https://supunsetunga.medium.com/writing-a-parser-getting-started-44ba70bb6cc9 
    - Using my ast structure I bascially just follow my grammar adding ast nodes as I match up correct syntax
    - Very strict on type checking, no conversions so if something is an int everything that makes it up needs to be an int

AST.py
    - Abstract syntax tree object based off the AST given in the COMP 3220 assignments
    - Basically just a tree that has a node that can point down to a child or right to a sibling

SymbolTable.py
    - Really just a dictionary with symbols that you can lookup by symbol and scope

Instruction.py
    - Instruction object that will make up the list that my three address code returns

TAC.py  
    - Converts AST to three address code
    - https://stackoverflow.com/questions/23769041/translate-ast-to-three-address-code
        - Took idea from here about a function that generates fresh temp variables and labels
    - Right now every expression gets set to a temp variable but I think I'm going to try and fix this in the optimizations part
    
ConstantFoldingOptimization.py
    - Does Constant Folding Optimization

TempVarRemoverOptimization.py
    - Removes unnecessary temp variables 
    - Example
        t1 = 1 + 2
        x = t1
        This would just become
        x = 1 + 2
    - Had to fix and rename temp varibales to include % to not throw off other optimizations

AlgerbraicSimplificationOptimization.py 
    - Simplifies small algebra things like x + 0, x - 0, x * 1, x / 1, ...

ConstantPropagation.py
    - propagates constants across instruction that are inside on one basic block
    - Once we hit a new label refresh the dictionary holding our constants so that we don't go across basic blocks

EasyDeadCodeElimination
    - Looks through the whole c program and adds live variables
    - Then loops through again and gets rid of unused variables
    - Not on a basic block scale but on a program level

AssemblyInstruction.py
    - Assembly instruction object with operation, destination, source, and label fields
    - Provides formatted output for x86-64 assembly code

Assembler.py
    - Translates TAC to x86-64 assembly language
    - Maps function parameters to positive stack offsets (rbp+16, rbp+24, etc.)
    - Maps local variables to negative stack offsets (rbp-4, rbp-8, etc.)
    - Handles function prologue/epilogue 
    - Supports arithmetic, assignments, function calls, and control flow

